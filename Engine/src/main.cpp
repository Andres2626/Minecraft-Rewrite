#include "common.h"
#include "Graphics/Shader/Shader.h"
#include "Player.h"
#include "Tile.h"
#include "Level.h"
#include "Chunk.h"
#include "Graphics/Camera/Camera.h"
#include "Graphics/Texture.h"
#include "App/Window.h"
#include "Utils/Util.h"
#include "Host/init.h"
#include "Graphics/Renderer.h"
#include "Graphics/Camera/Ray.h"
#include "Utils/Timer.h"
#include "Utils/Timestep.h"
#include "Hitresult.h"
#include "Selector.h"
#include "App/Application.h"
#include "../build.h" /* autogenerated build counter (view engine/update_counter.bat)*/

#include <GLFW\glfw3.h>
#include <stb_image.h>

#include <stdio.h>
#include <vector>

#define COUNTER_INTERFACE     1
#define TPS                   60.0f
#define WIN_X                 1024
#define WIN_Y                 768
#define WIN_TITLE             "Game"

using namespace MC;
using namespace Graphics;
using namespace Utils;
using namespace Physics;
using namespace App;
using namespace Events;
using namespace Layer;

class Rubydung : public DefaultLayer {
private:
	glm::vec2 last;
	Shader* sh_chunk, *sh_sel;
	Selector* py_sel;
	Level* lev;
	Player* steve;
	Texture tex;
	Window InternalWindow;
	Timer* tm;
	bool last_mouse_left, last_mouse_right;
public:
	Rubydung()
		: InternalWindow(Application::GetInstance().GetWindow())
	{
		this->tm = new Timer();
	}

	~Rubydung() 
	{
		delete this->steve;
		delete this->lev;
		delete this->py_sel;
		delete this->sh_sel;
		delete this->sh_chunk;
		delete this->tm;
	}

	void Init() override
	{
		DefaultLayer::Init();

		WindowProperties pr = this->InternalWindow.GetProps();

		/* load window icon */
		GLFWimage icon[1];
		icon[0].pixels = stbi_load("assets/Internal/win_icon.png", &icon[0].width, &icon[0].height,
			0, 4);

		if (!icon[0].pixels)
			MC_FATAL("Error loading window icon.");

		this->InternalWindow.SetIcon(icon);
		stbi_image_free(icon[0].pixels);

		/* set initial cursor position */
		last = { pr.x / 2, pr.y / 2 };

		/* load shader programs */
		sh_chunk = new Shader("assets/Shaders/chunk.shader");
		sh_sel = new Shader("assets/Shaders/selector.shader");

		/* initialize chunk renderer */
		glDepthFunc(GL_LEQUAL);
		Renderer::Enable(GL_DEPTH_TEST);
		Renderer::ClearColor({ 0.5f, 0.8f, 1.0f });

		/* create player selector */
		py_sel = new Selector();

		/* create level */
		lev = new Level({ 256, 256, 64 });

		/* setup player */
		steve = new Player(lev);
		steve->cam.aspect = (float)pr.x / (float)pr.y;

		/* load texture */
		tex.LoadFromFile("assets/terrain.png", GL_NEAREST);
	}

	void OnUpdate(Utils::Timestep& ts) override 
	{
		DefaultLayer::OnUpdate(ts);
		steve->tick(InternalWindow.GetWindow());
	}

	void OnEvent(Events::Event& ev) override 
	{
		DefaultLayer::OnEvent(ev);

		while (InternalWindow.GetEvent(ev)) {
			switch (ev.type) {
			case GLEQ_KEY_PRESSED:
				if (ev.keyboard.key == GLFW_KEY_ESCAPE) {
					lev->Save();
					Application::GetInstance().Stop();
				}
				if (ev.keyboard.key == GLFW_KEY_ENTER)
					lev->Save();
				break;
			case GLEQ_WINDOW_RESIZED:
				Renderer::Viewport({ 0, 0 }, { ev.size.width, ev.size.height });
				steve->cam.aspect = (float)ev.size.width / (float)ev.size.height;
				break;
			case GLEQ_CURSOR_MOVED:
				glm::vec2 pos(ev.pos.x, ev.pos.y);
				glm::vec2 offset(pos.x - last.x, last.y - pos.y);
				last = pos;

				/* player mouse handler */
				steve->turn(offset);
				break;
			}
			InternalWindow.FreeEvent(ev);
		}
	}

	void OnRender() override 
	{
		DefaultLayer::OnRender();

		/* GAME RENDER MAIN PROCESS:
		 * -- Enable chunk shader
		 * -- Render player (get clip matrix view player.cpp)
		 * -- Update player
		 * -- Set fog uniforms in the chunk shader
		 * -- Render level
		 * -- Enable selector shader
		 * -- PlayerPick process
		 */
		sh_chunk->Bind();
		steve->Render(sh_chunk);
		steve->Update();

		sh_chunk->SetVec3("s_cpos", steve->cam.pos);
		sh_chunk->SetVec4("s_fcolor", { 14 / 255.0f, 11 / 255.0f, 10 / 255.0f, 1.0f });
		sh_chunk->SetFloat("s_fstart", -10.0f);
		sh_chunk->SetFloat("s_fend", 20.0f);

		lev->Render(sh_chunk, steve);

		sh_sel->Bind();
		sh_sel->Set4x4("s_VP", steve->cam.GetProj() * steve->cam.GetView());

		PlayerPick();
	}

	void OnTick() override 
	{
		DefaultLayer::OnTick();

#if _DEBUG
		MC_INFO("fps: %i ups: %i cups: %i", Application::GetInstance().GetFPS(), Application::GetInstance().GetUPS(), lev->GetUpdates());
#else
		printf("%i fps, %i\n", Application::GetInstance().GetFPS(), lev->GetUpdates());
#endif
	}

	void OnSuspended() override 
	{
		DefaultLayer::OnSuspended();
	}
public:
	bool Raycast(const glm::vec3& org, const glm::vec3 dir, Hitresult& ret)
	{
		glm::vec3 d = dir;
		glm::vec3 lpoint = org;
		glm::ivec3 lblock = glm::floor(org);
		Ray camray;

		for (float t = 0.0f; t < 5.0f; t += 0.1f) {
			/* get point by parametric equation f(t) = dir * t + pos */
			glm::vec3 equation = camray.GetRay(t, org, d);

			/* impact block */
			glm::ivec3 blockpos = glm::floor(equation);

			if (blockpos != lblock && lev->IsSolidTile(blockpos)) {
				glm::ivec3 normal = lblock - blockpos;

				/* obtain block face normal */
				if (normal == glm::ivec3(0)) {
					glm::vec3 ad = abs(d);

					if (ad.x >= ad.y && ad.x >= ad.z)
						normal = glm::ivec3((dir.x > 0) ? -1 : 1, 0, 0);
					else if (ad.y >= ad.x && ad.y >= ad.z)
						normal = glm::ivec3(0, (dir.y > 0) ? -1 : 1, 0);
					else
						normal = glm::ivec3(0, 0, (dir.z > 0) ? -1 : 1);
				}

				ret.block = blockpos;
				ret.dis = t;
				ret.face = normal;
				ret.point = equation;

				return true;
			}

			lpoint = equation;
			lblock = blockpos;
		}

		return false;
	}

	void PlayerPick()
	{
		/* Obtain the vectors of parametric equation f(t) = ray * d + pos */
		glm::vec3 ray = steve->cam.front;
		glm::vec3 org = steve->cam.pos;

		/* Result of the hit */
		Hitresult ret;

		/* The camera hit solid block? */
		bool hit = Raycast(org, ray, ret);

		if (hit) {
			/* Render player selector */
			py_sel->SetHit(ret);
			py_sel->Render(steve->cam, sh_sel, tm->ElapsedMillis());

			/* Get mouse button status */
			bool left = glfwGetMouseButton(InternalWindow.GetWindow(), GLFW_MOUSE_BUTTON_1) == GLFW_PRESS;
			bool right = glfwGetMouseButton(InternalWindow.GetWindow(), GLFW_MOUSE_BUTTON_2) == GLFW_PRESS;

			/* Avoid block spam */
			if (left && !last_mouse_left)
				lev->SetTile(ret.block, 0); /* delete tile */

			if (right && !last_mouse_right)
				lev->SetTile(ret.block + ret.face, 1); /* set tile */

			/* Update mouse state */
			last_mouse_left = left;
			last_mouse_right = right;
		}
	}
};

class Game : public Application {
public:
	Game()
		: Application(WIN_TITLE, { WIN_X, WIN_Y, { true } })
	{ }

	~Game()
	{ }

	void Init() override
	{
		Application::Init();

		PushLayer(new Rubydung());
	}
};

int main(int argc, char** argv) {
	mc_host_init(argc, argv);
	mc_init_log(1, CONSOLE_MODE);

#if defined (COUNTER_INTERFACE)
	MC_WARN("RubyDung rd-133221 build: %i", BUILD_COUNT);
#endif

	/* initialize random number generator */
	srand(time(NULL));

	Game game;
	game.Start();
	return 0;
}